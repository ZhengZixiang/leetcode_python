# 问题
判断两个链表是否相交，如果相交，找出他们的交点。
![无环](http://hi.csdn.net/attachment/201106/28/0_13092441349Gz2.gif)
# 思路
两个链表相交存在两种情况，一个是无环，一个是有环。
- 暴力
遍历两个链表，具体说来，遍历链表1每个节点时，遍历一次链表2，判断是否在链表2中，时间复杂度为O(N*M)。

- Hash计数法
如果两个链表相交，两个链表就会有交点，而节点地址是唯一节点标识。对第一个链表所有节点地址建立Hash表，结束条件为遍历到最后一个None节点（无环）或者Hash表中该地址已存在（有环）。
然后对第二个链表的节点地址查询是否存在于Hash表。时间复杂度为O(M+N)。

- 第一个链表尾节点指向第二个链表头节点
编程之美上的思路。即使是无环相交，也能构造成有环相交的情况，如图所示。这样问题就转换成了判断一个链表李是否有环的问题，并且从链表2的头节点开始遍历。这个方法容易判断两个链表是否相交（时间复杂度O(M)），但是不容易找到交点。
![构造环](http://hi.csdn.net/attachment/201106/28/0_1309244135GYEy.gif)

- 尾节点必然相同
仔细思考上图，两个链表相交，那么最后一个节点必然相同，否则不相交。思路就变成了分别遍历两个链表到尾节点，判断尾节点是否相同。
![尾节点](http://hi.csdn.net/attachment/201106/28/0_13092441351oVu.gif)
判断是否相交后，接下来就是找到交点，将长度较长的链表从头向后移动|M-N|个位置。之所以这么移动，是因为交点以后两个链表尾部是一致的，当两个链表等长后，同时向后面遍历，当第一个节点相同时则是交点。

- 两个辅助栈反向找第一个不相同的尾部节点
和上个思路相似，既然两个链表在某一节点开始尾部是一致的，那么使用两个辅助栈，分别将两个链表所有节点push到栈中，再每次从两个栈中pop出个节点判断是否一致，当不一致时，说明上一次pop出的就是尾节点。
